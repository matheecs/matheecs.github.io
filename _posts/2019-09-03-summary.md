---
layout: post
title: "机器人视觉总结"
categories: study
author: "Jixiang Zhang"
---

**目录**

* toc
{:toc}
------

## LeetCode 50题

#### 数组、字符串
- Two Sum
  - Hash table
  - Brute force
  - Two pointers
- Valid Palindrome
  - Two pointers
- Implement strstr()
  - Brute force
  - KMP?
- Reverse Words in a String
  - In-place reverse
  - "reverse twice"
- String to Integer (atoi)
  - Overflow?
- Valid Number
- Longest Substring Without Repeating Characters
  - DP
- Longest Substring with At Most Two Distinct Characters
  - DP
- Missing Ranges
- Longest Palindromic Substring
  - Brute force
  - DP
- One Edit Distance
- Read N Characters Given Read4
- Read N Characters Given Read4 – Call multiple times
  - "edge cases to consider"

#### 数学
- Reverse Integer
  - Overflow
- Plus One
- Palindrome Number

#### 链表
- Merge Two Sorted Lists
  - dummyHead
- Add Two Numbers
  - carry
- Swap Nodes in Pairs
  - prev, p, q, r
- Merge K Sorted Linked Lists
  - Brute force
  - Heap
  - Divide and conquer
- Copy List with Random Pointer
  - deep copy

#### 二叉树

#### 位操作

#### MISC

#### 栈

#### 动态规划

#### 二分查找
模板
```c++
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = (right + left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```

```
因为我们初始化 right = nums.length - 1
所以决定了我们的「搜索区间」是 [left, right]
所以决定了 while (left <= right)
同时也决定了 left = mid+1 和 right = mid-1

因为我们只需找到一个 target 的索引即可
所以当 nums[mid] == target 时可以立即返回
```

## 三维视觉（VO、SLAM、SfM和VIO）

### 前端
- 初始化
  - E与H
- 旋转表示
  - 四元数
  - 角轴
  - $SO(3)$
  - 旋转矩阵
  - 欧拉角
  - 插值？
- 特征提取、匹配
  - 低通滤波器
  - 高通滤波器
  - Canny
  - 图像金字塔
  - Multi-scale detection
  - NMS
  - Hough Transform
  - Harris
  - SIFT
  - FAST
  - ORB = Oriented FAST + Rotated BRIEF
  - FLANN
  - SuperPoint
    - PyTorch
  - Convolutional Neural Networks
    - 卷积
    - ReLU
    - 池化
    - 全连接
  - 匹配
    - SAD（ZSAD）
    - SSD（ZSSD）
    - NCC（ZNCC）
      - $\cos\theta$
    - Hamming 距离
    - Census Transform
    - Patch 块
    - HOG 梯度
- Big Three
  - DLT
  - SVD
  - RANSAC
- 单目成像
  - H（相机纯旋转或平面场景），DOF=8，rank=3
  - 相机标定
    - 3D情况用6点法
    - 2D情况用4点法
  - P3P
- ICP?
  - RGB-D
- 对极几何
  - E（相机内参已知情况下），DOF=5，rank=2，5点法，8点法
  - F（相机内参未知情况下），DOF=7，rank=2，7点法，8点法
  - 三角化（DLT + SVD）
- 光流法
  - Constant Flow
  - Horn-Schunck
  - Forwards Additive（Lucas-Kanade）
  - Inverse Compositional（Baker-Matthews）
- 直接法
  - 深度滤波器
- IMU 模型

### 后端
- KF
  - EKF
  - UKF?
  - IEKF
  - PF?
- MSCKF
  - 零空间处理
- SWF
  - 边缘化
- BA
  - GN $\mathbf{J^\top J\Delta x=-J^\top f}$
  - LM = GN + 梯度法
  - Dog-Leg?
- FEJ
- 能观性
  - 零空间
- 预积分
- 因子图
  - MRF
  - Bayesian Network
  - iSAM(2)
    - miniSAM
    - GTSAM
    - AprilSAM

### 闭环
- Pose Graph
- BoW
- k-d tree
- K-means
- Geometric Verification
- Nearest Neighbor
- NetVLAD
- VINS-kidnap
- 步骤
  1. Query
  2. Match grouping
  3. Temporal consistency
  4. Geometrical consistency
  5. Loop closure

### 双目VO框架
[十四讲](https://github.com/gaoxiang12/slambook2/tree/master/ch13)

### VIO框架
[VINS-Mono code without Ceres or ROS](https://github.com/HeYijia/VINS-Course)

### 双目MSCKF框架
- [MSCKF_VIO](https://github.com/KumarRobotics/msckf_vio)
- [一步步深入了解S-MSCKF](http://www.xinliang-zhong.vip/msckf_notes)
- [S-MSCKF图解](https://matheecs.tech/2019/05/23/MSCKF.html)

### SfM
- COLMAP
- TheiaSfM
- MVE
- VisualSFM

## 机器人学

### ROS
  - RViz
  - 通信
    - DDS（ROS 2）
    - LCM -> ZCM

### Teach-Repeat-Replan框架
  - Planning
    - local re-planning
    - global planning（前端A* + 后端Convex Optimization）
  - Perception
    - global deformable surfel mapping
    - local online ESDF mapping
  - Localization
    - global pose graph optimization
    - local visual-inertial fusion
  - Controlling
  - 凸优化
    - LP
    - QP
    - SOCP
    - SDP

### move_base vs. Behavior-based
- [move_base](https://github.com/ros-planning/navigation)

![](http://wiki.ros.org/move_base?action=AttachFile&do=get&target=overview_tf.png)

- [Move Base Flex](https://github.com/magazino/move_base_flex)

![](http://wiki.ros.org/move_base_flex?action=AttachFile&do=get&target=move_base_flex.png)

- iRobot
- Event Driven Programming
  - Event Queue
- Finite State Machine

### 激光SLAM
  - 粒子滤波
  - Cartographer
  - **LOAM**?

### Apollo框架

![](https://github.com/ApolloAuto/apollo/blob/master/docs/demo_guide/images/Apollo_1.png?raw=true)

### 其他开源框架
  - MRPT
  - PythonRobotics

### 控制
  - PID
  - MPC
  - 最优控制

### 机械臂

## 数据结构与算法

### 数组
- 区间
  - 左闭右开
  - 左闭右闭
- 双指针
- 反转

### 链表
- Dummy Node

### 二叉树

```c++
void traverse(TreeNode root) {
    // TODO: root 需要做什么?
    traverse(root.left);
    traverse(root.right);
}
```

递归遍历

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }

    helper(root, result);

    return result;
}

private void helper(TreeNode root, List<Integer> result) {
    if (root == null) {
        return;
    }

    helper(root.left, result); // line 0
    result.add(root.val);      // line 1
    helper(root.right, result);// line 2
}
```

迭代遍历

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }

    Stack<Integer> systemStack = new Stack<>(); // 表示函数进度
    Stack<TreeNode> paramStack = new Stack<>(); // 表示函数输入参数

    systemStack.push(0);
    paramStack.push(root);

    while (!systemStack.isEmpty()) {
        int curLine = systemStack.pop();
        TreeNode curParam = paramStack.peek();

        // 提前将当前进度后移，因为后面可能会有其他函数入栈
        systemStack.push(curLine + 1);

        if (curLine == 0) {
            if (curParam.left != null) {
                systemStack.push(0);
                paramStack.push(curParam.left);
            }
        } else if (curLine == 1) {
            result.add(curParam.val);
        } else if (curLine == 2) {
            if (curParam.right != null) {
                systemStack.push(0);
                paramStack.push(curParam.right);
            }
        } else {
            systemStack.pop();
            paramStack.pop();
        }
    }

    return result;
}
```

### 递归（自上而下）= 迭代 + stack
$f(n) \rightarrow f(n-1) + f(n-2)$

### 动规（自下而上）
$f(n) \leftarrow f(n-1) + f(n-2)$

## 库与计算机系统

### C++ STL
  - vector

  ```c++
  std::reverse(myvector.begin(),myvector.end());

  bool myfunction(int i, int j) { return (i < j); }
  std::sort (myvector.begin(), myvector.end(), myfunction);

  int x = 10, y = 20;                          // x:10 y:20
  std::swap(x, y);                             // x:20 y:10
  std::vector<int> foo(4, x), bar(6, y);       // foo:4x20 bar:6x10
  std::swap(foo, bar);                         // foo:6x10 bar:4x20

  for (int i=1; i<10; ++i) myvector.push_back(i);                      // 1 2 3 4 5 6 7 8 9
  std::rotate(myvector.begin(), myvector.begin() + 3, myvector.end()); // 4 5 6 7 8 9 1 2 3

  for (int i=1; i<10; ++i) myvector.push_back(i);    // 1 2 3 4 5 6 7 8 9
  std::reverse(myvector.begin(), myvector.end());    // 9 8 7 6 5 4 3 2 1

  for (int i=1; i<10; ++i) myvector.push_back(i);    // 1 2 3 4 5 6 7 8 9
  std::random_shuffle(myvector.begin(), myvector.end());

  int myints[] = {10,20,30,30,20,10,10,20};
  std::vector<int> v(myints, myints+8);              // 10 20 30 30 20 10 10 20
  std::sort(v.begin(), v.end());                     // 10 10 10 20 20 20 30 30
  std::vector<int>::iterator low, up;
  low=std::lower_bound (v.begin(), v.end(), 20);
  up= std::upper_bound (v.begin(), v.end(), 20);
  std::cout << "lower_bound at position " << (low- v.begin()) << '\n';
  std::cout << "upper_bound at position " << (up - v.begin()) << '\n';

  auto result = std::minmax({1,2,3,4,5});
  std::cout << result.first << ' ' << result.second << '\n';

  mycount = std::count(myvector.begin(), myvector.end(), 20);

  std::vector<int>::iterator it = find(myvector.begin(), myvector.end(), 30);
  ```
  - list
  - map
    - 红黑树
  - unordered_map
    - 哈希表
  - stack
  - queue
- 面向对象
  - string
  - Big Three
    - 构造函数
      - 拷贝函数
      - 赋值构造
    - 析构函数
  - [虚函数与虚继承](https://www.cnblogs.com/fanzhidongyzby/archive/2013/01/14/2859064.html)
- 智能指针
  - shared_ptr
  - unique_ptr
- 指针和引用
- 右值和Move
- 内存空间

![](http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png)

- 多态
- [多线程?](https://blog.csdn.net/morewindows/article/details/7392749)
  - 同步
    - 互斥锁
    - 条件变量
    - 信号量
- 进程间通信的方式
  - 信号
  - 管道
  - 消息队列
  - 共享内存
- [C++面试集锦](https://www.cnblogs.com/Y1Focus/p/6707121.html)
- [常见C++面试题及基本知识点总结](https://www.cnblogs.com/LUO77/p/5771237.html)

### 常用库
  - OpenCV
  - Eigen
  - g2o
  - Ceres
  - OpenGV
  - PCL

### CSAPP
  - 处理器体系结构
  - 存储器层次结构
  - CUDA
  - CMake
  - Linux
    - [Linux内核系统架构介绍](https://mp.weixin.qq.com/s/Wl8sYr9ydrLCBpTdFamFnw?utm_source=tuicool&utm_medium=referral)

![](https://mmbiz.qpic.cn/mmbiz_jpg/2dibxhnGiaVKzIDsC9PviaUw3CYpTSgfUE7TLAXehW63VPCYzk8PEbH7pL9cJbx0uFyRNR87batfmyq6HYzJLCpAQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## （数值）线性代数
- X $\approx$ A * B
  - SVD
  - QR
  - PCA
  - 二次型
  - 条件数


## 参考资料
- [我所理解的机器人视觉](https://matheecs.tech/2019/04/12/robot-vision.html)
- [Tech Interview Handbook](https://yangshun.github.io/tech-interview-handbook)
- [~~Preparing for a Microsoft Interview~~](https://davidstutz.de/preparing-for-a-microsoft-interview)
- [Vision Algorithms for Mobile Robotics](http://rpg.ifi.uzh.ch/teaching.html)
- [Introduction to Autonomous Robots](https://github.com/correll/Introduction-to-Autonomous-Robots)
- [16-385 Computer Vision, Spring 2017](http://www.cs.cmu.edu/~16385/s17)
- [~~CS 123 Programming Your Personal Robot Course Materials~~](https://web.stanford.edu/class/cs123/materials.html)
- [How to Learn Robotics](https://qiu6401.gitbook.io/how-to-learn-robotics)
- [微信公众号：labuladong](https://mp.weixin.qq.com/s/sEZjsP4G_XNk-5lMVoZtpA)
  - [学习数据结构的框架思维](https://mp.weixin.qq.com/s?__biz=MzU0MDg5OTYyOQ==&mid=2247483857&idx=1&sn=918638e5a70e22b5b7bda9bbc5484f20&chksm=fb336193cc44e885f0524bdfe58a4e92b22a2b46017bf232b2ef91a576de648a8e61a30fd83d&scene=21#wechat_redirect)
  - [二分查找算法详解](https://mp.weixin.qq.com/s?__biz=MzU0MDg5OTYyOQ==&mid=2247484090&idx=1&sn=5635cf1c4fd8a8570b63c7ae9b4304c2&chksm=fb3362f8cc44ebee0a19a4cfba7f2e13923e05f47e15f2e99a1f42b01aeee83b946aceac3d4c&scene=21#wechat_redirect)
  - [双指针技巧汇总](https://mp.weixin.qq.com/s?__biz=MzU0MDg5OTYyOQ==&mid=2247484119&idx=1&sn=4e7a1389ced3b45de694605c03750d5d&chksm=fb336295cc44eb832640d174844f3622457c69b48c4a18e2f599a88eacb797af4f30bfe3312c&scene=21#wechat_redirect)
  - [动态规划详解](https://mp.weixin.qq.com/s?__biz=MzU0MDg5OTYyOQ==&mid=2247483818&idx=1&sn=6035f861d1b2bfd0178e842f26ac4836&chksm=fb3361e8cc44e8fe331154bfd32bd7b3b4f159bfad5d38d4a6b0b9f0d7e3485b93b828ee72cc&scene=21#wechat_redirect)
- [Single View and Two-View Geometry](http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/EPSRC_SSAZ/epsrc_ssaz.html)
- [Modern Robotics](http://hades.mech.northwestern.edu/index.php/Modern_Robotics)
- [Drake Tutorial](https://drake.guzhaoyuan.com/)

![微信 JxMathematica](/images/myWechat.jpeg)