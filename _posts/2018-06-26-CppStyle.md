---
layout: post
title: ROS C++ Style Guide 笔记
---

[ROS C++ Style Guide](http://wiki.ros.org/CppStyleGuide)

*Coding style is important. A clean, consistent style leads to code that is more readable, debuggable, and maintainable. We strive to write elegant code that will not only perform its desired function today, but will also live on, to be re-used and improved by other developers for many years to come.*

------

### 命名规则

- **CamelCased**: The name starts with a capital letter, and has a capital letter for each new word, with no underscores. 
- **camelCased**: Like CamelCase, but with a lower-case first letter.
- **under_scored**: The name uses only lower-case letters, with words separated by underscores. (yes, I realize that *under_scored* should be *underscored*, because it's just one word). 
- **ALL_CAPITALS**: All capital letters, with words separated by underscores.

#### 文件

All files are **under_scored**. 

Source files have the extension **.cpp**. 

Header files have the extension **.h**. 

Be descriptive, e.g., instead of **laser.cpp**, use **hokuyo_topurg_laser.cpp**. 

If the file primarily implements a class, name the file after the class. For example the class `ActionServer` would live in the file `action_server.h`.

##### 库

Libraries, being files, are **under_scored**. 

Don't insert an underscore immediately after the **lib** prefix in the library name.

#### Classes / Types

Class names (and other type names) are **CamelCased**.

#### 函数 / Methods

In general, function and class method names are **camelCased**, and arguments are **under_scored**. Functions and methods usually perform an action, so their name should make clear what they do: checkForErrors() instead of errorCheck(), dumpDataToFile() instead of dataFile(). Classes are often nouns. By making function names verbs and following other naming conventions programs can be read more naturally.

#### 变量

In general, variable names are **under_scored**.

##### Constants

Constants, wherever they are used, are **ALL_CAPITALS**.

##### Member variables

Variables that are members of a class (sometimes called fields) are **under_scored**, with a trailing underscore added.

##### Global variables

Global variables should almost never be used (see below for more on this). When they are used, global variables are **under_scored** with a leading **g_** added.

#### 命名空间

Namespace names are **under_scored**.

------

### 代码格式

Indent each block by 2 spaces. Never insert literal tab characters. 

The contents of a namespace are not indented. 

Braces, both open and close, go on their own lines (no "cuddled braces"). E.g.:

```c++
if(a < b)
{
  // do stuff
}
else
{
  // do other stuff
}
```

Braces can be omitted if the enclosed block is a single-line statement, e.g.:

```c++
if(a < b)
  x = 2*a;
```

Always include the braces if the enclosed block is more complex, e.g.:

```c++
if(a < b)
{
  for(int i=0; i<10; i++)
    PrintItem(i);
}
```

Here is a larger example:

```c++
/*
 * A block comment looks like this...
 */
#include <math.h>
class Point
{
public:
  Point(double xc, double yc) :
    x_(xc), y_(yc)
  {
  }
  double distance(const Point& other) const;
  int compareX(const Point& other) const;
  double x_;
  double y_;
};
double Point::distance(const Point& other) const
{
  double dx = x_ - other.x_;
  double dy = y_ - other.y_;
  return sqrt(dx * dx + dy * dy);
}
int Point::compareX(const Point& other) const
{
  if (x_ < other.x_)
  {
    return -1;
  }
  else if (x_ > other.x_)
  {
    return 1;
  }
  else
  {
    return 0;
  }
}
namespace foo
{
int foo(int bar) const
{
  switch (bar)
  {
    case 0:
      ++bar;
      break;
    case 1:
      --bar;
    default:
    {
      bar += bar;
      break;
    }
  }
}
} // end namespace foo

```

#### Line length

Maximum line length is 120 characters.

#### #ifndef guards

All headers must be protected against multiple inclusion by #ifndef guards, e.g.:

```c++
#ifndef PACKAGE_PATH_FILE_H
#define PACKAGE_PATH_FILE_H
...
#endif
```

This guard should begin immediately after the license statement, before any code, and should end at the end of the file.

------

### Preprocessor directives (#if vs. #ifdef)

For conditional compilation (except for the #ifndef guard explained above), always use #if, not #ifdef. 

Someone might write code like:

```c++
#ifdef DEBUG
        temporary_debugger_break();
#endif
```

Someone else might compile the code with turned-off debug info like:

```c++
cc -c lurker.cpp -DDEBUG=0
```

Always use #if, if you have to use the preprocessor. This works fine, and does the right thing, even if DEBUG is not defined at all.

```c++
#if DEBUG
        temporary_debugger_break();
#endif
```

------

### 命名空间

Use of namespaces to scope your code is encouraged. Pick a descriptive name, based on the name of the package. 

Never use a **using-directive** in header files. Doing so pollutes the namespace of all code that includes the header. 

It is acceptable to use **using-directives** in a source file. But it is preferred to use **using-declarations**, which pull in only the names you intend to use.

------

### 继承

Inheritance is the appropriate way to define and implement a common interface. The base class defines the interface, and the subclasses implement it. 

Inheritance can also be used to provide common code from a base class to subclasses. This use of inheritance is **discouraged**. In most cases, the "subclass" could instead contain an instance of the "base class" and achieve the same result with less potential for confusion. 

When overriding a virtual method in a subclass, always declare it to be **virtual,** so that the reader knows what's going on.

------

### Globals

Globals, both variables and functions, are **discouraged**. They pollute the namespace and make code less reusable. 

Global variables, in particular, are strongly **discouraged**. They prevent multiple instantiations of a piece of code and make multi-threaded programming a nightmare. 

Most variables and functions should be declared inside classes. The remainder should be declared inside namespaces. 

Exception: a file may contain a **main()** function and a handful of small helper functions that are global. But keep in mind that one day those helper function may become useful to someone else.

------

### Static class variables

Static class variables are **discouraged**. They prevent multiple instantiations of a piece of code and make multi-threaded programming a nightmare.

