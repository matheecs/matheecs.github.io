---
layout: post
title: "Clarabel"
categories: study
author: "Jixiang Zhang"
---

OSQP

$$
\begin{split}\begin{array}{ll}
  \mbox{minimize} & \frac{1}{2} x^T P x + q^T x \\
  \mbox{subject to} & l \leq A x \leq u
\end{array}\end{split}
$$

---

Clarabel

```math
\begin{array}{r}
\text{minimize} & \frac{1}{2}x^T P x + q^T x\\[2ex]
 \text{subject to} & Ax + s = b \\[1ex]
        & s \in \mathcal{K}
 \end{array}
```

Algorithm

```julia
# ----------
#  main loop
# ----------

# Scaling strategy
scaling = allows_primal_dual_scaling(s.cones) ? PrimalDual::ScalingStrategy : Dual::ScalingStrategy;

while true

    #update the residuals
    #--------------
    residuals_update!(s.residuals,s.variables,s.data)

    #calculate duality gap (scaled)
    #--------------
    μ = variables_calc_mu(s.variables, s.residuals, s.cones)

    # record scalar values from most recent iteration.
    # This captures μ at iteration zero.  
    info_save_scalars(s.info, μ, α, σ, iter)

    #convergence check and printing
    #--------------

    info_update!(
        s.info,s.data,s.variables,
        s.residuals,s.settings,s.timers
    )
    @notimeit info_print_status(s.info,s.settings)
    isdone = info_check_termination!(s.info,s.residuals,s.settings,iter)

    # check for termination due to slow progress and update strategy
    if isdone
        (action,scaling) = _strategy_checkpoint_insufficient_progress(s,scaling) 
        if     action ∈ [NoUpdate,Fail]; break;
        elseif action === Update; continue; 
        end
    end # allows continuation if new strategy provided

    
    #update the scalings
    #--------------
    is_scaling_success = variables_scale_cones!(s.variables,s.cones,μ,scaling)
    # check whether variables are interior points
    (action,scaling) = _strategy_checkpoint_is_scaling_success(s,is_scaling_success,scaling)
    if action === Fail;  break;
    else ();  # we only expect NoUpdate or Fail here
    end
        

    #increment counter here because we only count
    #iterations that produce a KKT update 
    iter += 1


    #Update the KKT system and the constant parts of its solution.
    #Keep track of the success of each step that calls KKT
    #--------------

    @timeit s.timers "kkt update" begin
    is_kkt_solve_success = kkt_update!(s.kktsystem,s.data,s.cones)
    end

    #calculate the affine step
    #--------------
    variables_affine_step_rhs!(
        s.step_rhs, s.residuals,
        s.variables, s.cones
    )

    @timeit s.timers "kkt solve" begin
    is_kkt_solve_success = is_kkt_solve_success && 
        kkt_solve!(
            s.kktsystem, s.step_lhs, s.step_rhs,
            s.data, s.variables, s.cones, :affine
        )
    end

    # combined step only on affine step success 
    if is_kkt_solve_success

        #calculate step length and centering parameter
        #--------------
        α = solver_get_step_length(s,:affine,scaling)
        σ = _calc_centering_parameter(α)

        #make a reduced Mehrotra correction in the first iteration
        #to accommodate badly centred starting points
        m = iter > 1 ? one(T) : α;

        #calculate the combined step and length
        #--------------
        variables_combined_step_rhs!(
            s.step_rhs, s.residuals,
            s.variables, s.cones,
            s.step_lhs, σ, μ, m
        )

        @timeit s.timers "kkt solve" begin
        is_kkt_solve_success =
            kkt_solve!(
                s.kktsystem, s.step_lhs, s.step_rhs,
                s.data, s.variables, s.cones, :combined
            )
        end

    end

    # check for numerical failure and update strategy
    (action,scaling) = _strategy_checkpoint_numerical_error(s, is_kkt_solve_success, scaling) 
    if     action === NoUpdate; ();  #just keep going 
    elseif action === Update; α = zero(T); continue; 
    elseif action === Fail;   α = zero(T); break; 
    end


    #compute final step length and update the current iterate
    #--------------
    α = solver_get_step_length(s,:combined,scaling)

    # check for undersized step and update strategy
    (action,scaling) = _strategy_checkpoint_small_step(s, α, scaling)
    if     action === NoUpdate; ();  #just keep going 
    elseif action === Update; α = zero(T); continue; 
    elseif action === Fail;   α = zero(T); break; 
    end 

    # Copy previous iterate in case the next one is a dud
    info_save_prev_iterate(s.info,s.variables,s.prev_vars)

    variables_add_step!(s.variables,s.step_lhs,α)

end  #end while
#----------
#----------
```
