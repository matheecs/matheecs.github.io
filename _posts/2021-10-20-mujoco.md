---
layout: post
title: "MuJoCo ç¬”è®°"
categories: study
author: "Jixiang Zhang"
---

> MuJoCo = **Mu**lti-**Jo**int dynamics with **Co**ntact

> MuJoCo = Modeling + Simulation + Visualization

[MuJoCo Documentation (old)](https://roboti.us/book/index.html)

[MuJoCo Documentation (new)](https://mujoco.readthedocs.io/en/latest/overview.html)

- Overview
- Computation
- Modeling -> XML Reference
- Programming -> API Reference

```
root [âš“] => /body/
    torso_to_abduct_fr_j [âš™+X] => /abduct_fr/
        abduct_fr_to_thigh_fr_j [âš™-Y] => /thigh_fr/
            thigh_fr_to_knee_fr_j [âš™-Y] => /shank_fr/
                toe_fr_joint [âš“] => /toe_fr/
    torso_to_abduct_fl_j [âš™+X] => /abduct_fl/
        abduct_fl_to_thigh_fl_j [âš™-Y] => /thigh_fl/
            thigh_fl_to_knee_fl_j [âš™-Y] => /shank_fl/
                toe_fl_joint [âš“] => /toe_fl/
    torso_to_abduct_hr_j [âš™+X] => /abduct_hr/
        abduct_hr_to_thigh_hr_j [âš™-Y] => /thigh_hr/
            thigh_hr_to_knee_hr_j [âš™-Y] => /shank_hr/
                toe_hr_joint [âš“] => /toe_hr/
    torso_to_abduct_hl_j [âš™+X] => /abduct_hl/
        abduct_hl_to_thigh_hl_j [âš™-Y] => /thigh_hl/
            thigh_hl_to_knee_hl_j [âš™-Y] => /shank_hl/
                toe_hl_joint [âš“] => /toe_hl/
```

<iframe src="//player.bilibili.com/player.html?aid=976157123&bvid=BV1d44y1x7m1&cid=428713204&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

### å‘½åçº¦å®š

| ç±»å‹å‰ç¼€ |                    ç”¨é€” |
| :------- | ----------------------: |
| mj       |        **æ ¸å¿ƒæ•°æ®ç»“æ„** |
| mjt      |            **ä¸»è¦ç±»å‹** |
| mjf      |        **å›è°ƒå‡½æ•°ç±»å‹** |
| mjv      |      å¯è§†åŒ–ç›¸å…³æ•°æ®ç»“æ„ |
| mjr      | OpenGL æ¸²æŸ“ç›¸å…³æ•°æ®ç»“æ„ |
| mjui     |         UI ç›¸å…³æ•°æ®ç»“æ„ |


| å‡½æ•°å‰ç¼€ |                ç”¨é€” |
| :------- | ------------------: |
| mj_      |            æ ¸å¿ƒå‡½æ•° |
| mju_     |            æ•°å­¦å‡½æ•° |
| mjv_     |      å¯è§†åŒ–ç›¸å…³å‡½æ•° |
| mjr_     | OpenGL æ¸²æŸ“ç›¸å…³å‡½æ•° |
| mjui_    |         UI ç›¸å…³å‡½æ•° |
| mjcb_    |    å…¨å±€å›è°ƒå‡½æ•°æŒ‡é’ˆ |

### å…¨å±€å›è°ƒå‡½æ•°

```c++
// callbacks extending computation pipeline
MJAPI extern mjfGeneric  mjcb_passive;
MJAPI extern mjfGeneric  mjcb_control;
MJAPI extern mjfConFilt  mjcb_contactfilter;
MJAPI extern mjfSensor   mjcb_sensor;
MJAPI extern mjfTime     mjcb_time;
MJAPI extern mjfAct      mjcb_act_dyn;
MJAPI extern mjfAct      mjcb_act_gain;
MJAPI extern mjfAct      mjcb_act_bias;
```

### mjModel æ•°æ®ç»“æ„

å…·ä½“å†…å®¹

- æ¨¡å‹å­æ¨¡å—çš„å…·ä½“æ•°ç›®
- ç‰©ç†å¼•æ“å‚æ•°ã€å¯è§†åŒ–å‚æ•°ã€æ¨¡å‹ç»Ÿè®¡
- ç¼“å†²åŒºæŒ‡é’ˆ

### mjData æ•°æ®ç»“æ„

å…·ä½“å†…å®¹

- å¤´éƒ¨å†…å®¹
  - æ ˆå’Œç¼“å†²åŒºçš„ç©ºé—´
  - æ ˆæŒ‡é’ˆ
  - å†…å­˜ä½¿ç”¨ç»Ÿè®¡
  - è¯Šæ–­ä¿¡æ¯
  - å˜é‡æ•°ç›®
  - å…¨å±€å±æ€§
  - ç¼“å†²åŒºæŒ‡é’ˆ
- è¾“å…¥è¾“å‡º
  - çŠ¶æ€é‡
  - æ§åˆ¶é‡
  - åŠ¨åŠ›å­¦
    - `qacc`
  - ä¼ æ„Ÿå™¨æ•°æ®
- ä½ç½®ä¾èµ–å‹æ•°æ®
- ä½ç½®ã€é€Ÿåº¦ä¾èµ–å‹æ•°æ®
- ä½ç½®ã€é€Ÿåº¦ã€æ§åˆ¶é‡/åŠ é€Ÿåº¦ä¾èµ–å‹æ•°æ®
  - `qfrc_inverse`

### [HOW TO ä»¿çœŸ](https://mujoco.readthedocs.io/en/latest/programming.html#simulation)

#### åˆå§‹åŒ– = mjModel + mjData

åˆå§‹åŒ– mjModel

```c++
// option 1: parse and compile XML from file
mjModel* m = mj_loadXML("mymodel.xml", NULL, errstr, errstr_sz);

// option 2: parse and compile XML from virtual file system
mjModel* m = mj_loadXML("mymodel.xml", vfs, errstr_sz);

// option 3: load precompiled model from MJB file
mjModel* m = mj_loadModel("mymodel.mjb", NULL);

// option 4: load precompiled model from virtual file system
mjModel* m = mj_loadModel("mymodel.mjb", vfs);

// option 5: deep copy from existing mjModel
mjModel* m = mj_copyModel(NULL, mexisting);
```

åˆå§‹åŒ– mjData

```c++
// option 1: create mjDada corresponding to given mjModel
mjData* d = mj_makeData(m);

// option 2: deep copy from existing mjData
mjData* d = mj_copyData(NULL, m, dexisting);
```

é‡Šæ”¾èµ„æº

```c++
// deallocate existing mjModel
mj_deleteModel(m);

// deallocate existing mjData
mj_deleteData(d);
```

#### ä»¿çœŸä¸»å¾ªç¯ = æ­£åŠ¨åŠ›å­¦ + ç§¯åˆ†

```c++
// simulate until t = 10 seconds
while( d->time<10 )
    mj_step(m, d);
```

**æ§åˆ¶é‡å›è°ƒå‡½æ•°æ–¹å¼ (å®˜æ–¹æ¨èçš„æ–¹æ³•â€¼ï¸)**

```c++
// simple controller applying damping to each dof
void mycontroller(const mjModel* m, mjData* d)
{
    if( m->nu==m->nv )
        mju_scl(d->ctrl, d->qvel, -0.1, m->nv);
}

// install control callback
mjcb_control = mycontroller;
```

**é”™è¯¯çš„**æ§åˆ¶é‡ç›´æ¥èµ‹å€¼æ–¹å¼âŒ

```c++
while( d->time<10 )
{
    // set d->ctrl or d->qfrc_applied or d->xfrc_applied
    mj_step(m, d);
}
```

**æ­£ç¡®çš„**æ§åˆ¶é‡ç›´æ¥èµ‹å€¼æ–¹å¼

```c++
while( d->time<10 )
{
    mj_step1(m, d);
    // set d->ctrl or d->qfrc_applied or d->xfrc_applied
    mj_step2(m, d);
}
```

**`mj_step/mj_step1/mj_step2` å®ç°ç»†èŠ‚**

```c++
void mj_step(const mjModel* m, mjData* d)
{
    // common to all integrators
    mj_checkPos(m, d);
    mj_checkVel(m, d);
    mj_forward(m, d);
    mj_checkAcc(m, d);

    // compare forward and inverse solutions if enabled
    if( mjENABLED(mjENBL_FWDINV) )
        mj_compareFwdInv(m, d);

    // use selected integrator
    if( m->opt.integrator==mjINT_RK4 )
        mj_RungeKutta(m, d, 4);
    else
        mj_Euler(m, d);
}

void mj_step1(const mjModel* m, mjData* d)
{
    mj_checkPos(m, d);
    mj_checkVel(m, d);
    mj_fwdPosition(m, d);
    mj_sensorPos(m, d);
    mj_energyPos(m, d);
    mj_fwdVelocity(m, d);
    mj_sensorVel(m, d);
    mj_energyVel(m, d);

    // if we had a callback we would be using mj_step, but call it anyway
    if( mjcb_control )
        mjcb_control(m, d);
}

void mj_step2(const mjModel* m, mjData* d)
{
    mj_fwdActuation(m, d);
    mj_fwdAcceleration(m, d);
    mj_fwdConstraint(m, d);
    mj_sensorAcc(m, d);
    mj_checkAcc(m, d);

    // compare forward and inverse solutions if enabled
    if( mjENABLED(mjENBL_FWDINV) )
        mj_compareFwdInv(m, d);

    // integrate with Euler; ignore integrator option
    mj_Euler(m, d);
}
```

#### çŠ¶æ€é‡å’Œæ§åˆ¶é‡

```
x = (mjData.time, mjData.qpos, mjData.qvel, mjData.act)
u = (mjData.ctrl, mjData.qfrc_applied, mjData.xfrc_applied)
```

åœ¨å…³èŠ‚ç©ºé—´æ–½åŠ åŠ›/åŠ›çŸ© - `mjData.qfrc_applied`
åœ¨æ¬§å¼ç©ºé—´æ–½åŠ åŠ›/åŠ›çŸ© - `mjData.xfrc_applied`

```
dx/dt = mj_forward(t,x,u) = (1, mjData.qvel, mjData.qacc, mjData.act_dot)
```

æ¸…æ¥šæ‰€æœ‰æ§åˆ¶é‡

```c++
// clear controls and applied forces
mju_zero(dst->ctrl, m->nu);
mju_zero(dst->qfrc_applied, m->nv);
mju_zero(dst->xfrc_applied, 6*m->nbody);
```

âš ï¸Note that MuJoCo will not clear these controls/forces at the end of the time step. This is the responsibility of the user.

#### æ­£åŠ¨åŠ›å­¦

```c++
void mj_forwardSkip(const mjModel* m, mjData* d,
                    int skipstage, int skipsensor)
{
    // position-dependent
    if( skipstage<mjSTAGE_POS )
    {
        mj_fwdPosition(m, d);
        if( !skipsensor )
            mj_sensorPos(m, d);
        if( mjENABLED(mjENBL_ENERGY) )
            mj_energyPos(m, d);
    }

    // velocity-dependent
    if( skipstage<mjSTAGE_VEL )
    {
        mj_fwdVelocity(m, d);
        if( !skipsensor )
            mj_sensorVel(m, d);
        if( mjENABLED(mjENBL_ENERGY) )
            mj_energyVel(m, d);
    }

    // acceleration-dependent
    if( mjcb_control )
        mjcb_control(m, d);
    mj_fwdActuation(m, d);
    mj_fwdAcceleration(m, d);
    mj_fwdConstraint(m, d);
    if( !skipsensor )
        mj_sensorAcc(m, d);
}
```

#### é€†åŠ¨åŠ›å­¦ RNE (MuJoCo ç‰¹æœ‰åŠŸèƒ½) -> state estimation, system identification and optimal control

æœ‰è§£æè§£ï¼Œç”¨äºæ­£åŠ¨åŠ›å­¦çš„çƒ­å¯åŠ¨

è¾“å…¥ï¼š
```
(mjData.qpos, mjData.qvel, mjData.qacc, mjData.mocap_pos, mjData.mocap_quat)
```

è¾“å‡ºï¼š`mjData.qfrc_inverse`

mjData.qfrc_inverse = mjData.qfrc_applied + Jacobian'*mjData.xfrc_applied + mjData.qfrc_actuator

#### å¤šçº¿ç¨‹

ç•¥

#### æ¨¡å‹è°ƒæ•´

ç•¥

#### æ•°æ®ç»“æ„çš„å†…å­˜å¸ƒå±€å’Œç¼“å†²åŒºåˆ†é…

çŸ©é˜µå…ƒç´ æŒ‰ç…§è¡Œçš„æ–¹å¼ (row-major) å­˜å‚¨

linear memory array `a0,a1,...,a5` represents the 2x3 matrix

```
a0 a1 a2
a3 a4 a5
```

çº¦æŸé›…å¯æ¯”çŸ©é˜µ `mjData.efc_J` é‡‡ç”¨ç¨€ç–è¡¨ç¤º (compressed sparse row)

3D å§¿æ€ç”¨å•ä½å››å…ƒæ•° `q = (w,x,y,z)` è¡¨ç¤º

MuJoCo also uses 6D [spatial vectors](http://royfeatherstone.org/spatial/) internally.

[X Macros](https://en.wikipedia.org/wiki/X_Macro)

#### å†…éƒ¨æ ˆç©ºé—´

ç•¥

#### é”™è¯¯ã€è­¦å‘Šå’Œå†…å­˜åˆ†é…

ç•¥

#### è¯Šæ–­

æ—¶é—´ç»Ÿè®¡

#### **é›…å¯æ¯”**

**Jacobian maps joint velocities to end-effector velocities, while the transpose of the Jacobian maps end-effector forces to joint forces.**

`mj_jac`

#### ç¢°æ’

```
mjtNum* contactforce = d->efc_force + d->contact[i].efc_address;
```

#### åæ ‡ç³»ä¸å˜æ¢çŸ©é˜µ

- å…³èŠ‚åæ ‡ç³»
- ç¬›å¡å°”åæ ‡

### References

- [How to slice an STL file to fit your 3D printer](https://www.youtube.com/watch?v=e9VeyBNnH1g)
- [MuJoCo Programming](https://mujoco.readthedocs.io/en/latest/programming.html)
- [MIT Locomotion (Python Implementation)](https://github.com/google-research/motion_imitation/tree/master/mpc_controller)
- [MIT Locomotion (C++ Implementation)](https://github.com/mit-biomimetics/Cheetah-Software)
- [towr](https://github.com/ethz-adrl/towr)
- [CasADi](https://web.casadi.org)
- [Multi-Body Dynamics w/ **Contact**](http://underactuated.csail.mit.edu/multibody.html)
- [Non-Linear Trajectory Optimization for Large Step-Ups: Application to the Humanoid Robot Atlas](https://github.com/S-Dafarra/variable-height-double-pendulum)
- [Video: Dynamic Optimization Modeling in CasADi](https://www.youtube.com/watch?v=DvicSVRhVxQ)
- [Courses from Systems Control and Optimization LaboratoryğŸ‘](https://www.syscop.de/teaching)